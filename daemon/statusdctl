#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR_DEFAULT="$(cd "$SCRIPT_DIR/.." && pwd)"
ROOT_DIR="${PI_STATUSBAR_ROOT:-$ROOT_DIR_DEFAULT}"

if [[ ! -f "$ROOT_DIR/daemon/pi_statusd.py" ]]; then
  if [[ -f "$SCRIPT_DIR/pi_statusd.py" ]]; then
    ROOT_DIR="$SCRIPT_DIR/.."
  elif [[ -f "$SCRIPT_DIR/../libexec/pi-statusbar/daemon/pi_statusd.py" ]]; then
    ROOT_DIR="$SCRIPT_DIR/../libexec/pi-statusbar"
  fi
fi

DAEMON="$ROOT_DIR/daemon/pi_statusd.py"
HTTP_DAEMON="$ROOT_DIR/daemon/pi_statusd_http.py"
STATE_DIR="$HOME/.pi/agent"
PID_FILE="$STATE_DIR/statusd.pid"
LOG_FILE="$STATE_DIR/statusd.log"
SOCKET_FILE="$STATE_DIR/statusd.sock"
CONFIG_FILE="$STATE_DIR/statusd.json"

HTTP_PID_FILE="$STATE_DIR/statusd-http.pid"
HTTP_LOG_FILE="$STATE_DIR/statusd-http.log"
HTTP_CONFIG_FILE="$STATE_DIR/statusd-http.json"

mkdir -p "$STATE_DIR"

assert_layout() {
  if [[ ! -f "$DAEMON" ]]; then
    echo "Could not locate daemon script: $DAEMON"
    echo "Set PI_STATUSBAR_ROOT to your repo/install root (contains daemon/pi_statusd.py)."
    exit 1
  fi
  if [[ ! -f "$HTTP_DAEMON" ]]; then
    echo "Could not locate HTTP daemon script: $HTTP_DAEMON"
    echo "Set PI_STATUSBAR_ROOT to your repo/install root (contains daemon/pi_statusd_http.py)."
    exit 1
  fi
}

is_running() {
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

find_pid_fallback() {
  pgrep -f "daemon/pi_statusd.py" | head -n1 || true
}

find_all_pids() {
  pgrep -f "daemon/pi_statusd.py" || true
}

is_http_running() {
  if [[ -f "$HTTP_PID_FILE" ]]; then
    local pid
    pid="$(cat "$HTTP_PID_FILE" 2>/dev/null || true)"
    if [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

find_http_pid_fallback() {
  pgrep -f "daemon/pi_statusd_http.py" | head -n1 || true
}

find_all_http_pids() {
  pgrep -f "daemon/pi_statusd_http.py" || true
}

start_daemon() {
  if is_running; then
    echo "pi-statusd already running (pid $(cat "$PID_FILE"))."
    return 0
  fi

  local fallback_pid
  fallback_pid="$(find_pid_fallback)"
  if [[ -n "$fallback_pid" ]] && kill -0 "$fallback_pid" 2>/dev/null; then
    echo "$fallback_pid" > "$PID_FILE"
    echo "pi-statusd already running (pid $fallback_pid)."
    return 0
  fi

  nohup python3 "$DAEMON" >> "$LOG_FILE" 2>&1 &
  local pid=$!
  echo "$pid" > "$PID_FILE"

  sleep 0.2

  if kill -0 "$pid" 2>/dev/null; then
    echo "Started pi-statusd (pid $pid)."
  else
    echo "Failed to start pi-statusd. Check $LOG_FILE"
    exit 1
  fi
}

stop_daemon() {
  local pids
  pids="$(find_all_pids)"

  if [[ -z "$pids" ]]; then
    echo "pi-statusd is not running."
    rm -f "$PID_FILE" "$SOCKET_FILE"
    return 0
  fi

  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue
    kill "$pid" 2>/dev/null || true
  done <<< "$pids"

  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue
    for _ in {1..20}; do
      if ! kill -0 "$pid" 2>/dev/null; then
        break
      fi
      sleep 0.1
    done
    if kill -0 "$pid" 2>/dev/null; then
      kill -9 "$pid" 2>/dev/null || true
    fi
  done <<< "$pids"

  rm -f "$PID_FILE" "$SOCKET_FILE"
  echo "Stopped pi-statusd."
}

start_http() {
  if is_http_running; then
    echo "pi-statusd-http already running (pid $(cat "$HTTP_PID_FILE"))."
    return 0
  fi

  local fallback_pid
  fallback_pid="$(find_http_pid_fallback)"
  if [[ -n "$fallback_pid" ]] && kill -0 "$fallback_pid" 2>/dev/null; then
    echo "$fallback_pid" > "$HTTP_PID_FILE"
    echo "pi-statusd-http already running (pid $fallback_pid)."
    return 0
  fi

  nohup python3 "$HTTP_DAEMON" >> "$HTTP_LOG_FILE" 2>&1 &
  local pid=$!
  echo "$pid" > "$HTTP_PID_FILE"
  sleep 0.2

  if kill -0 "$pid" 2>/dev/null; then
    echo "Started pi-statusd-http (pid $pid)."
  else
    echo "Failed to start pi-statusd-http. Check $HTTP_LOG_FILE"
    exit 1
  fi
}

stop_http() {
  local pids
  pids="$(find_all_http_pids)"

  if [[ -z "$pids" ]]; then
    echo "pi-statusd-http is not running."
    rm -f "$HTTP_PID_FILE"
    return 0
  fi

  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue
    kill "$pid" 2>/dev/null || true
  done <<< "$pids"

  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue
    for _ in {1..20}; do
      if ! kill -0 "$pid" 2>/dev/null; then
        break
      fi
      sleep 0.1
    done
    if kill -0 "$pid" 2>/dev/null; then
      kill -9 "$pid" 2>/dev/null || true
    fi
  done <<< "$pids"

  rm -f "$HTTP_PID_FILE"
  echo "Stopped pi-statusd-http."
}

daemon_status() {
  if is_running; then
    local pid
    pid="$(cat "$PID_FILE")"
    echo "pi-statusd running (pid $pid)"
  else
    local fallback_pid
    fallback_pid="$(find_pid_fallback)"
    if [[ -n "$fallback_pid" ]] && kill -0 "$fallback_pid" 2>/dev/null; then
      echo "$fallback_pid" > "$PID_FILE"
      echo "pi-statusd running (pid $fallback_pid)"
    else
      echo "pi-statusd not running"
      return 1
    fi
  fi

  if python3 "$DAEMON" --request ping >/dev/null 2>&1; then
    echo "socket: healthy ($SOCKET_FILE)"
  else
    echo "socket: not responding"
    return 1
  fi
}

http_status() {
  local ok=0
  if is_http_running; then
    local pid
    pid="$(cat "$HTTP_PID_FILE")"
    echo "pi-statusd-http running (pid $pid)"
  else
    echo "pi-statusd-http not running"
    ok=1
  fi

  python3 - <<PY || ok=1
import hashlib, json, pathlib, ssl
p = pathlib.Path("$HTTP_CONFIG_FILE")
cfg = {}
if p.exists():
    try:
        cfg = json.loads(p.read_text())
    except Exception:
        cfg = {}

host = cfg.get("host", "0.0.0.0")
port = cfg.get("port", 8787)
token = cfg.get("token", "")
https_enabled = bool(cfg.get("https_enabled", True))
https_host = cfg.get("https_host", host)
https_port = cfg.get("https_port", 8788)
cert_path = pathlib.Path(cfg.get("https_cert_path", str(pathlib.Path.home() / ".pi" / "agent" / "statusd-http-cert.pem"))).expanduser()

fp = "unavailable"
if cert_path.exists():
    try:
        pem = cert_path.read_text()
        der = ssl.PEM_cert_to_DER_cert(pem)
        h = hashlib.sha256(der).hexdigest().upper()
        fp = ":".join(h[i:i+2] for i in range(0, len(h), 2))
    except Exception:
        fp = "invalid-cert"

print(f"http:  {host}:{port} token={'set' if token else 'unset'}")
print(f"https: {https_host}:{https_port} enabled={'yes' if https_enabled else 'no'} cert={cert_path} sha256={fp}")
PY

  return "$ok"
}

http_token() {
  local token="${1:-}"
  python3 - <<PY
import json, pathlib, secrets
p = pathlib.Path("$HTTP_CONFIG_FILE")
p.parent.mkdir(parents=True, exist_ok=True)
try:
    cfg = json.loads(p.read_text()) if p.exists() else {}
except Exception:
    cfg = {}

tok = "$token".strip()
if not tok:
    tok = str(cfg.get("token") or "").strip() or secrets.token_urlsafe(24)
cfg["token"] = tok
cfg.setdefault("host", "0.0.0.0")
cfg.setdefault("port", 8787)
cfg.setdefault("allow_loopback_unauth", True)
cfg.setdefault("https_enabled", True)
cfg.setdefault("https_host", cfg.get("host", "0.0.0.0"))
cfg.setdefault("https_port", 8788)
cfg.setdefault("https_cert_path", str(pathlib.Path.home() / ".pi" / "agent" / "statusd-http-cert.pem"))
cfg.setdefault("https_key_path", str(pathlib.Path.home() / ".pi" / "agent" / "statusd-http-key.pem"))
p.write_text(json.dumps(cfg, indent=2) + "\n")
print(tok)
PY
}

http_cert_fingerprint() {
  python3 - <<PY
import hashlib, json, pathlib, ssl
p = pathlib.Path("$HTTP_CONFIG_FILE")
cfg = {}
if p.exists():
    try:
        cfg = json.loads(p.read_text())
    except Exception:
        cfg = {}
cert_path = pathlib.Path(cfg.get("https_cert_path", str(pathlib.Path.home() / ".pi" / "agent" / "statusd-http-cert.pem"))).expanduser()
if not cert_path.exists():
    print("")
    raise SystemExit(0)
try:
    pem = cert_path.read_text()
    der = ssl.PEM_cert_to_DER_cert(pem)
    h = hashlib.sha256(der).hexdigest().upper()
    print(":".join(h[i:i+2] for i in range(0, len(h), 2)))
except Exception:
    print("")
PY
}

terminal_get() {
  python3 - <<PY
import json, pathlib
p = pathlib.Path("$CONFIG_FILE")
if not p.exists():
    print("auto")
else:
    try:
        cfg = json.loads(p.read_text())
    except Exception:
        cfg = {}
    print(cfg.get("terminal", "auto"))
PY
}

terminal_set() {
  local val="${1:-auto}"
  local low
  low="$(printf '%s' "$val" | tr '[:upper:]' '[:lower:]')"
  case "$low" in
    auto|system|default)
      val="auto"
      ;;
    ghostty)
      val="Ghostty"
      ;;
    iterm2|iterm)
      val="iTerm2"
      ;;
    terminal)
      val="Terminal"
      ;;
    *)
      echo "Invalid terminal: $val"
      echo "Valid values: auto, Ghostty, iTerm2, Terminal"
      exit 2
      ;;
  esac

  python3 - <<PY
import json, pathlib
p = pathlib.Path("$CONFIG_FILE")
p.parent.mkdir(parents=True, exist_ok=True)
try:
    cfg = json.loads(p.read_text()) if p.exists() else {}
except Exception:
    cfg = {}
cfg["terminal"] = "$val"
p.write_text(json.dumps(cfg, indent=2) + "\n")
print("terminal set to:", cfg["terminal"])
PY
}

ensure_daemon() {
  if ! is_running; then
    start_daemon
  fi

  if python3 "$DAEMON" --request ping >/dev/null 2>&1; then
    echo "pi-statusd ready"
    return 0
  fi

  echo "pi-statusd started but socket is not ready yet"
  return 1
}

show_help() {
  cat <<'EOF'
Usage: statusdctl <command>

Commands:
  start                   Start pi-statusd in background
  stop                    Stop running pi-statusd
  restart                 Restart pi-statusd
  ensure                  Ensure pi-statusd is running and socket responds
  status                  Show process + socket health
  ping                    Check daemon socket health only
  latest <pid>            Show latest assistant message for pid (telemetry-backed)
  send <pid> <msg>        Send message to pid (mux first, then pi-bridge, then tty/ui fallback)
  watch [ms] [fp]         Wait for status/message change and return event JSON
  terminal                Show configured default terminal (auto/Ghostty/iTerm2/Terminal)
  terminal <value>        Set terminal: auto | Ghostty | iTerm2 | Terminal

  http-start              Start HTTP bridge for remote clients
  http-stop               Stop HTTP bridge
  http-restart            Restart HTTP bridge
  http-status             Show HTTP/HTTPS bridge process + config summary
  http-token [value]      Get or set bearer token in ~/.pi/agent/statusd-http.json
  http-cert-fingerprint   Print HTTPS cert SHA256 fingerprint (for iOS pinning)
EOF
}

assert_layout

cmd="${1:-status}"
case "$cmd" in
  start)
    start_daemon
    ;;
  stop)
    stop_daemon
    ;;
  restart)
    stop_daemon
    start_daemon
    ;;
  status)
    daemon_status
    ;;
  ensure)
    ensure_daemon
    ;;
  ping)
    python3 "$DAEMON" --request ping
    ;;
  latest)
    if [[ $# -lt 2 ]]; then
      echo "Usage: statusdctl latest <pid>"
      exit 2
    fi
    python3 "$DAEMON" --request "latest $2"
    ;;
  send)
    if [[ $# -lt 3 ]]; then
      echo "Usage: statusdctl send <pid> <message>"
      exit 2
    fi
    pid="$2"
    shift 2
    python3 "$DAEMON" --request "send $pid $*"
    ;;
  watch)
    if [[ $# -eq 1 ]]; then
      python3 "$DAEMON" --request "watch"
    elif [[ $# -eq 2 ]]; then
      python3 "$DAEMON" --request "watch $2"
    else
      python3 "$DAEMON" --request "watch $2 $3"
    fi
    ;;
  terminal)
    if [[ $# -ge 2 ]]; then
      terminal_set "$2"
    else
      terminal_get
    fi
    ;;
  http-start)
    start_http
    ;;
  http-stop)
    stop_http
    ;;
  http-restart)
    stop_http
    start_http
    ;;
  http-status)
    http_status
    ;;
  http-token)
    if [[ $# -ge 2 ]]; then
      http_token "$2"
    else
      http_token
    fi
    ;;
  http-cert-fingerprint)
    http_cert_fingerprint
    ;;
  *)
    show_help
    exit 2
    ;;
esac
